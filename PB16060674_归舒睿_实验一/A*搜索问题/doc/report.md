# A* 和 IDA* 算法实验报告

##### PB16060674-归舒睿

[TOC]

## 运行方式

根目录下：  
```shell
make
cd bin
./Astar
./IDAstar
```

## 启发函数的选择

选择曼哈顿距离：  
* 曼哈顿距离和欧式距离符合距离出口越近越好的直觉
* 启发函数加上cost满足A*的最优性
* 选择曼哈顿而不是欧式距离是由于曼哈顿的计算只有加减法，计算速度高于欧氏距离的计算

## 程序说明

### A*

内部定义了程序中所使用的数据结构：  

* A：矩阵迷宫
* node：A*算法衍生记录的数据结构，内部包括父指针，坐标，延伸方向，cost，f值（启发函数+cost的值），排序是从小到大（用于构建优先队列）  

* scannedNode：存放已遍历节点（即存放非叶节点的树）  
* nodeQueue：优先队列，存放叶节点（即将拓展），排序按照f值  

函数说明：

* mazeOutput(int, int)：打印矩阵，其中将存入参数的坐标位置标红，用于debug，也可以用于显示走迷宫过程
* inputInit：用于初始化，从输入文件中读取输入
* f(structNode)：用于计算node的fvalue
* extend(structNode)：拓展传入优先队列中fvalue最小的node，将拓展的node计算fvalue后加入优先队列
* AstarSearch()：搜索主函数

时间复杂度：O($4^n$)-------------n为步数  
空间复杂度：O($4^n$) 

优化后，保证不重复走：  
时间复杂度：O($3^n$)-------------n为步数  
空间复杂度：O($3^n$) 

**但测试发现，在这个数据下，优化后由于分支判断也需要花时间，而实际始终保持最低fvalue(m+n)行走，因此在此数据下实际上是负优化，因此去掉此优化**

### IDA*

数据结构：  

* A：矩阵
* fmax：fvalue的阈值，迭代深度上限
* finished：完成标志

函数说明：  

* mazeOutput(int, int)：迷宫输出
* inputInit：文件输入迷宫
* f(int, int, pathLen)：当前遍历点fvalue的计算
* IDAstarSearch(int, string, int, int)：每次固定上限的搜索函数
* main：主函数，变换fvalue上限，调用输入和搜索函数

时间复杂度：最坏O($4^n$)，n为深度--优化->保证不重复跑O(m),m为迷宫可走位置数  
空间复杂度：O(1)  

**但测试发现，在这个数据下，优化后由于分支判断也需要花时间，而实际始终保持最低fvalue(m+n)行走，因此在此数据下实际上是负优化，因此去掉此优化**  

两者对比：  
| attribute | A* | IDA* |
|-----------|----|------|
|  步数      | 39 | 39   |
| 运行时间   | 0.000319 | 0.000027|


