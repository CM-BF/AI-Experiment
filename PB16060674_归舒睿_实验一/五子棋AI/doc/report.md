# 五子棋实验报告

##### PB16060674-归舒睿

[TOC]

## 运行方法

根目录下：  
1：  
`./run.sh`  

2：  
```shell
make
./bin/fiveInARow
```

## 评分函数


### 得分单元

根据五子棋术语：活五，活/半/死 四，活/半/死 三，活/半/死 二，单，来作为加分单元。  
其分值根据重要性程度，人为设计。  
```C++
#define GOAL_FIVE MAX_GOAL
#define GOAL_ALIVE_FOUR 6000
#define GOAL_SEMI_FOUR 1000
#define GOAL_DEAD_FOUR 50
#define GOAL_ALIVE_THREE 500
#define GOAL_SEMI_THREE 100
#define GOAL_DEAD_THREE 35
#define GOAL_ALIVE_TWO 30
#define GOAL_SEMI_TWO 10
#define GOAL_DEAD_TWO 5
#define GOAL_SINGLE 0
```

### 棋盘得分

根据遍历整个棋盘，行列正斜反斜中的得分单元进行计分，得分考虑到双三，双四等高度威胁，因此采用多个相同得分单元，会以个数n，单元得分*($n^m$)来计分（m是某参数，通常设为2）。  
然后正负得分进行加权和：goal = maxGoal * 1.2 - minGoal;  从加权可以看出AI偏向与进攻（1.2的偏高权重）  

## 剪枝策略

剪枝的作用是加快AI的响应速度，剪去不需要考虑的情况

### 剪枝优化

剪枝的效果取决于排序的好坏，于是尽量迅速的找到a和b的最好边界值可大幅度的剪枝。  

因此我的剪枝排序采取一种**威胁优先**的方式拓展，来优化剪枝：  
* 每一步棋盘都会有个棋盘大小的dangeRate，其中每个坐标表明这那个点的**威胁**
* **威胁**来自于五子棋术语“威胁”的拓展：此处的威胁是得分单元连线上的两个端点，如：三个子的头尾两个端点。
* **威胁**的值也直接与产生威胁的得分单元的得分相关
* 并且，考虑到双威胁，如双三，双四，三四等，威胁的累计方式是乘法，如一个活三的威胁是250则，两个活三的威胁是250*250（因为下一子就可以连成双四，具有十分高的威胁度），此方法，很好的考虑了双威胁的情况
* 于是，拓展节点的优先顺序便和威胁值相关

## 搜索范围

易知，考虑没有威胁的位置没有什么价值，因此我们采用`wideLevel`来作为考虑的范围，其表示考虑的棋子周边的距离。

## 思考深度
思考深度由`maxDepth`来调节

## 棋力

棋力不知道用段位怎么估计，但是maxDepth=7，wideLevel=2，再加上偏进攻的下棋策略，我目前无法打败它。  
在其maxDepth=5的情况下，可以打败。  
与其对战确实提高了自己的棋力，自己不得不想办法考虑得比设置的深度更深，否则无法打败它。  

## 思考题

1. 思考深度的增加，会造成指数增长的负担，对效率影响非常大，但是其智能程度也很大程度提高。增加思考深度，可以让其做出浅思考深度看不到的更优解，当增加思考深度到可以找到必胜解的时候，就算找到最优解了。  
2. 此题排序顺序根据**威胁值**来排序，具体在剪枝优化部分已经说明了，请参考**剪枝优化**部分。
3. 出错说明实际上ai设定的某个棋局评分错误的高或低于某个棋局的评分，因此，需要根据两个棋局的对比，通过不同，把不同的得分单元的评分进行调整（即让ai会自动调整得分单元的参数），即可让其不在相同以及类似的地方犯错。

## 一局结果

output.txt中是在搜索7深度，2范围的情况下比较会下棋的舍友和ai下的一局，由于舍友最后失误，败给ai。（舍友还败过几次，在同样难度的ai上）